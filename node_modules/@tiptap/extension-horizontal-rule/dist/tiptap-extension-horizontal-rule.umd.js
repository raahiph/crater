(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tiptap/core'), require('prosemirror-state')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tiptap/core', 'prosemirror-state'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/extension-horizontal-rule'] = {}, global.core, global.prosemirrorState));
}(this, (function (exports, core, prosemirrorState) { 'use strict';

  const HorizontalRule = core.Node.create({
      name: 'horizontalRule',
      defaultOptions: {
          HTMLAttributes: {},
      },
      group: 'block',
      parseHTML() {
          return [
              { tag: 'hr' },
          ];
      },
      renderHTML({ HTMLAttributes }) {
          return ['hr', core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      addCommands() {
          return {
              setHorizontalRule: () => ({ chain }) => {
                  return chain()
                      // remove node before hr if it’s an empty text block
                      .command(({ tr, dispatch }) => {
                      const { selection } = tr;
                      const { empty, $anchor } = selection;
                      const isEmptyTextBlock = $anchor.parent.isTextblock
                          && !$anchor.parent.type.spec.code
                          && !$anchor.parent.textContent;
                      if (!empty || !isEmptyTextBlock || !dispatch) {
                          return true;
                      }
                      const posBefore = $anchor.before();
                      tr.deleteRange(posBefore, posBefore + 1);
                      return true;
                  })
                      .insertContent({ type: this.name })
                      // add node after hr if it’s the end of the document
                      .command(({ tr, dispatch }) => {
                      var _a;
                      if (dispatch) {
                          const { parent, pos } = tr.selection.$from;
                          const posAfter = pos + 1;
                          const nodeAfter = tr.doc.nodeAt(posAfter);
                          if (!nodeAfter) {
                              const node = (_a = parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                              if (node) {
                                  tr.insert(posAfter, node);
                                  tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, posAfter));
                              }
                          }
                          tr.scrollIntoView();
                      }
                      return true;
                  })
                      .run();
              },
          };
      },
      addInputRules() {
          return [
              core.nodeInputRule(/^(?:---|—-|___\s|\*\*\*\s)$/, this.type),
          ];
      },
  });

  exports.HorizontalRule = HorizontalRule;
  exports['default'] = HorizontalRule;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-extension-horizontal-rule.umd.js.map
