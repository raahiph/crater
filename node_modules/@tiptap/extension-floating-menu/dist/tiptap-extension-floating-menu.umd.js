(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tiptap/core'), require('prosemirror-state'), require('tippy.js')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tiptap/core', 'prosemirror-state', 'tippy.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/extension-floating-menu'] = {}, global.core, global.prosemirrorState, global.tippy));
}(this, (function (exports, core, prosemirrorState, tippy) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var tippy__default = /*#__PURE__*/_interopDefaultLegacy(tippy);

  class FloatingMenuView {
      constructor({ editor, element, view, tippyOptions, shouldShow, }) {
          this.preventHide = false;
          this.shouldShow = ({ state }) => {
              const { selection } = state;
              const { $anchor, empty } = selection;
              const isRootDepth = $anchor.depth === 1;
              const isEmptyTextBlock = $anchor.parent.isTextblock
                  && !$anchor.parent.type.spec.code
                  && !$anchor.parent.textContent;
              if (!empty || !isRootDepth || !isEmptyTextBlock) {
                  return false;
              }
              return true;
          };
          this.mousedownHandler = () => {
              this.preventHide = true;
          };
          this.focusHandler = () => {
              // we use `setTimeout` to make sure `selection` is already updated
              setTimeout(() => this.update(this.editor.view));
          };
          this.blurHandler = ({ event }) => {
              var _a;
              if (this.preventHide) {
                  this.preventHide = false;
                  return;
              }
              if ((event === null || event === void 0 ? void 0 : event.relatedTarget)
                  && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
                  return;
              }
              this.hide();
          };
          this.editor = editor;
          this.element = element;
          this.view = view;
          if (shouldShow) {
              this.shouldShow = shouldShow;
          }
          this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });
          this.editor.on('focus', this.focusHandler);
          this.editor.on('blur', this.blurHandler);
          this.element.style.visibility = 'visible';
          // We create tippy asynchronously to make sure that `editor.options.element`
          // has already been moved to the right position in the DOM
          requestAnimationFrame(() => {
              this.createTooltip(tippyOptions);
          });
      }
      createTooltip(options = {}) {
          this.tippy = tippy__default['default'](this.editor.options.element, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: true,
              trigger: 'manual',
              placement: 'right',
              hideOnClick: 'toggle',
              ...options,
          });
      }
      update(view, oldState) {
          var _a;
          const { state, composing } = view;
          const { doc, selection } = state;
          const { from, to } = selection;
          const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
          if (composing || isSame) {
              return;
          }
          const shouldShow = this.shouldShow({
              editor: this.editor,
              view,
              state,
              oldState,
          });
          if (!shouldShow) {
              this.hide();
              return;
          }
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.setProps({
              getReferenceClientRect: () => core.posToDOMRect(view, from, to),
          });
          this.show();
      }
      show() {
          var _a;
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
      }
      hide() {
          var _a;
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
      }
      destroy() {
          var _a;
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
          this.element.removeEventListener('mousedown', this.mousedownHandler);
          this.editor.off('focus', this.focusHandler);
          this.editor.off('blur', this.blurHandler);
      }
  }
  const FloatingMenuPlugin = (options) => {
      return new prosemirrorState.Plugin({
          key: typeof options.pluginKey === 'string'
              ? new prosemirrorState.PluginKey(options.pluginKey)
              : options.pluginKey,
          view: view => new FloatingMenuView({ view, ...options }),
      });
  };

  const FloatingMenu = core.Extension.create({
      name: 'floatingMenu',
      defaultOptions: {
          element: null,
          tippyOptions: {},
          pluginKey: 'floatingMenu',
          shouldShow: null,
      },
      addProseMirrorPlugins() {
          if (!this.options.element) {
              return [];
          }
          return [
              FloatingMenuPlugin({
                  pluginKey: this.options.pluginKey,
                  editor: this.editor,
                  element: this.options.element,
                  tippyOptions: this.options.tippyOptions,
                  shouldShow: this.options.shouldShow,
              }),
          ];
      },
  });

  exports.FloatingMenu = FloatingMenu;
  exports.FloatingMenuPlugin = FloatingMenuPlugin;
  exports.FloatingMenuView = FloatingMenuView;
  exports['default'] = FloatingMenu;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-extension-floating-menu.umd.js.map
